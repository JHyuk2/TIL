# A형을 준비하는 사람을 위해

## 1. 문제 유형

1) Simulation (시뮬레이션) - 대체로 쉽다고 느껴지는 문제이다. 

2) Brute Force/Greedy (완전탐색, 로컬최적화)

3) BFS - 최단거리 탐색

**4) DFS/DP** - 재귀 + 메모~ 작은 문제를 풀고 큰 문제에 적용하는 과정.

- 사실상 문제를 재귀적으로 푸는 방법이라고 보면 된다.

- key/value쌍의 조작(해쉬맵)
- 시간이나 공간이 한계가 있는 



### TIP

- 모든 문제를 접할 때 가장 먼저 접하는 방법은 (1) 시뮬레이션과 (2) 완전탐색이다.
- 한 문제를 풀더라도 여러 가지 방법으로 풀어보는 건 좋은 접근이다.



## 2. A형 시험을 위한 자료구조

IM은 사실 인덱스조작(Index Manipulation) 위주의 문제가 많이 나왔기 때문에 조금만 돌려보면 비슷하게 적용해서 풀 수 있는 문제가 많다. 하지만 다음 시험부터는 자원이 제한되어 있는 경우가 대부분이기 때문에 이를 위해 자료구조 배움의 필요성이 높아진다.



삼성 시험은 사실 디테일한 효율성까지는 보지 않고, 다른 사이트와 다르게 import시 다른 내장함수를 다 긁어오기 때문에 deque를 import하지 않고 리스트로 사용하는 방법이 오히려 좋을 수도 있다.



Binary Search Tree를 그리고, 뒤집고, 컴퓨터공학적 시험은 사실 삼성 시험에는 자주 나오는 문제는 아니다.

오히려 Linked List와 같이 모든 것의 기본이 되는 것은 처음부터 끝까지 한 번 구현해보는 것도 좋은 방법이다.



### 선형 자료 구조 _ Linear

​	자료(데이터)들간의 관계가 없거나, 1:1이다.



- [x] 배열 - 2차원 리스트
- [x] 스택 - 원통형 기둥
- [ ] 큐
- [ ] 링크드리스트 - 큐의 근간이 되는 것으로써 **후에 깊게 다룰 예정**이다.
- [ ] 데크

### 비선형 자료 구조 _ Non Linear

​	자료(데이터)들로 현실세계를 모델링 할 수 있는 것들로써 컴퓨테이셔널 문제 해결에서 중요한 위치에 있다.

​	마크 저커버그(페이스북 창업자)가 성공한 이유는 새로운 수학적 지표(활성화 사용자 수)를 내었기 때문에.

- [ ] 그래프
- [ ] 트리



	### 1) 그래프

​	각 점을 표현하는 `노드(Node)`와, 노드와 노드가 연결된 `간선(Edge)`로 표현된 자료구조.

​	==> 추가로 말하면 노드는 Vertex, 간선은 Arc라고 불리기도 한다.

	- 방향이 있는 방향그래프(di-graph)와 방향이 없는 무방향그래프(unirected graph) 로 나뉜다.
	- 또 모든 선이 연결된 연결 그래프 / 그렇지 않은 (끊어진 점이 있는) 비연결 그래프 그래프로 또 나뉜다.
	- 그리고 엣지마다 가중치가 주어진 가중치그래프(혹은 네트워크)와 그렇지 않은 그래프로 또 나뉜다.





#### 그림으로 비교하는 방향그래프 vs 무방향그래프

- 인접행렬로 나타낸 **무방향그래프**

<img src ='https://t1.daumcdn.net/cfile/tistory/2637025057BBFC5D11' width = '80%'>



- 인접행렬로 나타낸 **방향 그래프**

<img src = 'https://img1.daumcdn.net/thumb/R720x0.q80/?scode=mtistory2&fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F21029250584C0F24136E16'>



#### 여기서의 중요한 점은, 인접행렬과 인접 리스트로 나눴을 때의 차이이다.

#### 	

#### 1-1) 공간복잡도

- 인접 행렬
  - O(V**2) (정점의 개수) => 100만 x 100만이면 1조만큼이 필요하다.

- 인접 리스트
  - O(E) (간선의 개수). 
- 대부분의 경우 간선의 개수(E)가 (Vertex**2)보다는 적다.



#### 1-2) 시간 복잡도

- 인접행렬
  - 두 정점 간의 연결 여부(간선의 유무)를 확인하는데 유리(`O(1)`)
    - `G[a][b]`
  - 정점 A와 연결된 모든 간선
    - `O(|V|)`
- 인접리스트
  - 두 정점 간의 연결 여부(간선의 유무)를 확인하는데 유리()
- 비고
  - 완전그래프의 경우.





> BOJ - ABCDE 문제가 대표적인 기초 그래프 문제.
>
> ​	1) 인접 행렬이든 인접 리스트든 인풋으로 받아서 만들어보는 게 중요하다.

```python
V, E = map(int,input().split())

for _ in range(E):
    node1, node2 = map(int, input().split())
    # 1. 인접행렬로 만들기. (2중 배열)
    # [[]]
	    
    # 2. 인접 리스트로 만들기. (딕셔너리)
    # {N: []}
```



#### BFS (Breadth First Search)

너비 우선 탐색

`큐`를 활용하여 구현 - 들어온 순서대로 탐색한다.

=> 최단경로



#### DFS(Depth First Search)

깊이 우선 탐색

`스택`을 활용하여 구현 - 왼쪽으로 쭉 갔다가 없으면 한칸 올라가서 그 옆으로 가는 방법

일단 마지막까지 간 후에,  갈 수 있는 경우의수를 소진해나가는 방법.

=> 일단 다 뚫고 백트래킹 과정으로 길을 찾는 것이기 때문에

​	최단경로를 찾는 것과는 거리가 좀 있다.



1. 시작 정점 v를 결정하여 방문한다. - 보통 출발점이 주어진 경우가 많다.

2. 정점 v에 인접한 정점 중에서

   1) 방문하지 않은 정점 w가 있으면, 정점 v를 스택에 push하고 정점 w를 방문한다.

   ​	 그리고 w를 v로 하여 다시 2)를 반복한다.

   2)  방문하지 않은 정점이 없으면, 탐색의 방향을 바꾸기 위해서 

   ​	스택을 pop하여 받은 가장 마지막 방문 정점을 v로 하여 다시 2) 를 반복한다.

3. **스택이 공백이 될 때 까지 2)를 반복한다.**  - 더 이상 순회할 길이 없다.



- 준비물: visited[], stack[]

```python
DFS(v):
    v 방문;
    visited[v] <- True
    do {
        if (v의 인접 정점 중 방문 안한 w 찾기.)
        	push(v);
        while( w ) {
            w 방문;
            visited[w] <- True
            push(w);
            v <- w;
            v의 인접 정점 중 방문 안한 w 찾기
        }
        v <- pop(stack);
    } while(v)
end DFS()
```

즉 visited 리스트를 통해서 flag를 넣어주는 작업.

우리가 지나온 길은 flag를 넣어서 방문을 했음을 알 수 있고,

`헨델과 그레텔`

기본은 빵가루를 흘리면서 이동한다!!!



### 2) 트리

크게 보면 그래프의 하위 개념이다.



## 3. 사소한 팁



### 1) input() & sys.stdin.readline()

​	대부분의 사이트가 import sys, readline을 통해 읽는 것을 제한하고 있지만, 백준은 이를 허용함

​	그리고 readline을 사용하는 편이 훨씬 빠르기 때문에 사용하는 것이 좋은데 이 때 주의해야 할 점이 있다.

```python
'''
<input.txt>
6
(())())
(((()())()
(()())((()))
((()()(()))(((())))()
()()()()(()()())()
(()((())()(
'''

# input을 사용해서 받을 때
T = int(input())

for _ in range(T):
    tmp = list(input())
    print(tmp)
    
-------------------------------
import sys
T = int(input())

for _ in range(T):
    tmp = sys.stdin.readline()
    print(tmp)
   
# 한 줄만 뜯어서 비교해보면 다음과 같다.   

# input()
>>> ['(', '(', ')', ')', '(', ')', ')']

# sys.readline()
>>> ['(', '(', ')', ')', '(', ')', ')', '\n']
```

마지막 줄에 new line 이 새로 생긴다.