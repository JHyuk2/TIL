# 1. 30 알고리즘 쌤 

주말을 이용해서 아주 깊은 수준까지 공부를 해보자.

IT 직종을 희망하는 사람이라면 꼭 필요한 과정이다.

전부 문제풀이. 2~3문제.

computational thinking.. 단답형 주관식에 가까움

**재능보단 노력**

힘내자



# 1. 의사코드로 나타내기

`APS` (Advanced Program Solving)

- 알고리즘의 성능은 무엇으로 측정하는가?

  - 1) `정확성` : 얼마나 정확하게 동작하는가
  - 2) `작업량` : 얼마나 적은 연산으로 원하는 결과를 얻어내는가
  - 3) `메모리 사용량` : 얼마나 적은 메모리를 사용하는가
  - 4) `단순성` : 얼마나 단순한가
  - 5) `최적성` : 더 이상 개선할 여지없이 최적화되었는가

  

###  -          검증용 알고리즘       /                             최적화 알고리즘      

| 알고리즘 1                                                   | 알고리즘2                                                    |
| :----------------------------------------------------------- | ------------------------------------------------------------ |
| 1<br />+2<br />+3<br />+4<br />...<br />+100<br />-------------<br />5,050 | 100 x (1 + 100)   = 5,050<br />---------------------<br />    2 |



얼마나 효율적인가를 나타내는 지수는 **시간복잡도(Time Complexity)**를 통해 알 수 있다.



## 1. 1- 시간 복잡도 (Time Complexity)

###   1) 빅-오(O) 표기법

- 시간 복잡도 함수 중 가장 큰 영향력을 주는 n에 대한 항만을 표시

- 계수(Coefficient)는 생략하여 표시

- Ex)

  O(3\*N +2) = O(3N) = O(N)

  O(2N\*\*2 + 10\*N) = O(2N\**2)  ~~pow(n,2)~~

  - 즉, 충분히 큰 N에 대해서만 비교한다.

<img src = "http://rapapa.net/wp/wp-content/uploads/2018/04/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA-2018-04-13-%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE-6.48.30.png" style = "zoom: 50%" div="">

컴퓨터 구조와 자료구조 위주로 공부하면 좋을 것 같다.

(수치해석, 계산능력이 중요하다.)



ex) 지나가는 사람과 복사기 사용하는 사람을 구분해서 프린터기가 알아서 켜지게 되는 프로그램을 짜고 싶다.

- 전공자 : 24시간 녹화 -> 패턴분석을 통해 센서 여러개 설치 -> 필요한 센서만 남기고 다시 프로그래밍
- 비전공자: 바로 프로그래밍.. (이 설계부분이 빠져있다.)

즉, 전공 비전공은 사전지식(무언가를 해결하기 위한 제반지식)의 차이.

비전공자로서 그 부분을 채우기 위한 다른 강점이 필요하다. 



### 2) 배열 (Array)

일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조 (파이썬의 리스트)

- 프로그램 내에서 여러 개의 변수가 필요할 때 저장할 때 편함 - 하나의 선언으로 여러 개의 변수 저장 가능
- 단순히 다수의 변수 선언 뿐 아니라, Sequence를 이용하여 힘든 작업을 손쉽게 다룰 수도 있다.



## 2. Pycharm 실습

### 1) 디버깅

잘못한 부분을 잡는 게 디버깅이 아니다. 그건 에러 수정이다.

에러에 대한 부분은 보통 콘솔창에서 다 확인할 수 있으니, 그건 알아서 체크하자.

- **디버깅**은 **프로그램이 돌아가는 상태**에서
- 개발단계에서 **원하는 순서대로 실행되는지**를 체크하는것

==> 프린트가 편하면 프린트해서 결과를 보면 된다. 디버거가 그 역할을 대신해줄 뿐!



## 3. 알고리즘 수업

### 1) 순열  

nPr = n x (n-1) x (n-2) x (n-3) x ... (n-r+1)



### 2) 탐욕(Greedy) 알고리즘

탐욕 알고리즘은 최적해를 구하는 데 사용되는 근시안적인 방법.

가장 대표적인 예 -> 거스름돈 줄이기.

- 어떻게 하면 손님에게 주는 지폐와 동전의 개수를 최소한으로 줄일 수 있을까?

만약 500원, 400원, 100원짜리 동전이 있고, 거스름돈이 800원이라고 하자.

그러면 400원 두개를 주는 게 최적해가 되지만, 그리디는 500 + 100 * 3 이라는 결과로 나온다 (최적해 x)

사용에 주의를 해야한다.



<h4> baby-gin문제 </h4>
 0~9사이의 숫자 카드에서 임의의 카드 6장을 뽑았을 때 

- 3장의 카드가 **연속적인 번호**를 갖는 경우 `run` 

- 3장이 카드가 **같은 경우** `triplet`

- 6장의 카드가 **run, triplet으로만 구성된 경우** `baby-gin`

6자리 숫자를 입력받아 baby-gin 여부 판단하는 프로그램 작성하기.

ex) 667767 => 두 개의 triplet ==> baby-gin



Solution 1)

​	i. count 배열을 만들어서 0~9 를 카운트한다.

​	ii. triplet을 제거 후 run 찾기

Solution 2)

​	i. 마찬가지로 배열 생성

​	ii. run제거 후 triplet인지 확인.



### 3) 정렬

공부하는 과정에서는 min, max, sort, append를 가급적이면 사용하지 않고 써보자.

